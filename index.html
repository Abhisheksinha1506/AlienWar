<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AlienWar Survival Game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: 'Courier New', monospace;
      background-color: #1a1a1a;
      color: #ffffff;
      margin: 20px;
      overflow-x: hidden;
    }

    canvas {
      border: 2px solid #ffffff;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
      display: block;
      outline: none;
      /* Responsive styling */
      max-width: 100%;
      height: auto !important;
    }

    h1 {
      color: #00ff00;
      margin-bottom: 6px;
      text-align: center;
    }

    p {
      color: #cccccc;
      margin-top: 0;
      text-align: center;
      max-width: 600px;
    }

    .settings {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
    }

    @media (max-width: 600px) {
      .settings {
        flex-direction: column;
        gap: 15px;
      }
    }

    label {
      color: #cccccc;
    }

    select,
    button {
      font-family: 'Courier New', monospace;
      background-color: #333;
      color: #fff;
      border: 1px solid #00ff00;
      padding: 5px 8px;
      cursor: pointer;
    }

    button:hover {
      background-color: #00ff00;
      color: #000;
    }

    .score-info {
      margin-top: 8px;
      color: #888;
      font-size: 12px;
      text-align: center;
    }

    .score-info span {
      color: #00ff00;
    }

    /* ── Social Icons ────────────────────────────────────────────── */
    .social-links {
      position: absolute;
      top: 15px;
      right: 20px;
      display: flex;
      gap: 18px;
      z-index: 100;
    }

    .social-links a {
      color: #00ff00;
      font-size: 22px;
      text-decoration: none;
      transition: all 0.2s ease;
      opacity: 0.8;
    }

    .social-links a:hover {
      color: #ffffff;
      transform: translateY(-2px);
      opacity: 1;
      text-shadow: 0 0 10px #00ff00;
    }

    @media (max-width: 600px) {
      .social-links {
        position: static;
        margin-bottom: 20px;
        order: -1;
      }
    }
  </style>
</head>

<body>
  <div class="social-links">
    <a href="https://www.linkedin.com/in/abhisheksinha1506/" target="_blank" title="LinkedIn"><i
        class="fab fa-linkedin"></i></a>
    <a href="https://github.com/Abhisheksinha1506/AlienWar" target="_blank" title="GitHub"><i
        class="fab fa-github"></i></a>
    <a href="mailto:abhisheksinha1506@gmail.com" title="Email"><i class="fas fa-envelope"></i></a>
  </div>
  <h1>AlienWar Survival Game</h1>
  <p>Use <strong>arrow keys</strong> to move (hold for continuous movement) &mdash; dodge aliens, use walls as cover,
    and survive as long as possible!</p>
  <div class="settings">
    <label>Grid Size:
      <select id="gridSize">
        <option value="10">Small (10&times;10)</option>
        <option value="20" selected>Medium (20&times;20)</option>
        <option value="30">Large (30&times;30)</option>
      </select>
    </label>
    <label>Game Speed:
      <select id="gameSpeed">
        <option value="45">Slow (~1.3 ticks/s)</option>
        <option value="30" selected>Normal (~2 ticks/s)</option>
        <option value="15">Fast (~4 ticks/s)</option>
      </select>
    </label>
    <button onclick="applySettings()">Apply / Restart</button>
  </div>
  <p class="score-info">
    Score = <span>+1</span> per tick survived &nbsp;|&nbsp;
    <span>+5</span> bonus per alien on the board each tick &nbsp;|&nbsp;
    Best: <span id="bestScoreDisplay">0</span>
  </p>
  <script>
    // ═══════════════════════════════════════════════════════════════════════════
    // CONFIGURATION
    // ═══════════════════════════════════════════════════════════════════════════
    const MAX_CANVAS_WIDTH = 600;
    const WALL_CHANCE = 0.10;
    const ALIEN_SPAWN_RATE = 0.33;
    const MOVE_DELAY = 10;
    const SAFE_RADIUS = 2; // FIX: increased from 1 → 2 to ensure player has
    // more room to escape immediately after spawn.
    // Max aliens = 15% of grid cells — prevents flooding on small grids
    function maxAliens() {
      return Math.max(3, Math.floor(GRID_SIZE * GRID_SIZE * 0.15));
    }
    // ═══════════════════════════════════════════════════════════════════════════
    // MUTABLE GAME STATE
    // ═══════════════════════════════════════════════════════════════════════════
    let GRID_SIZE = 20;
    let CELL_SIZE = 30;
    let UPDATE_INTERVAL = 30;
    let grid = [];
    let wallNoise = [];
    let player = { x: 0, y: 0, displayX: 0, displayY: 0 };
    let aliens = [];
    let starfield = [];
    // FIX: alienPositionSet is a Set<"x,y"> tracking the LOGICAL alien positions.
    // Used to block player movement into alien cells even during the window when
    // updateGame() has vacated grid cells to '.'. Without this, the player could
    // phase through aliens because grid cells are temporarily '.' during the move phase.
    let alienPositionSet = new Set();
    let score = 0;
    let bestScore = 0;
    let scoreScale = 1;
    let gameOver = false;
    let gameOverAlpha = 0;
    let hitFlash = 0;
    let moveCooldown = 0;
    // Dedicated frame counter — resets on every initGame().
    let framesSinceStart = -1;
    // ═══════════════════════════════════════════════════════════════════════════
    // P5 — SETUP
    // ═══════════════════════════════════════════════════════════════════════════
    function setup() {
      CELL_SIZE = Math.floor(Math.min(MAX_CANVAS_WIDTH / GRID_SIZE, 30));
      let cnv = createCanvas(GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);
      cnv.elt.setAttribute('tabindex', '0');
      cnv.elt.focus();
      cnv.elt.addEventListener('click', () => cnv.elt.focus());
      // FIX: If the user clicks a dropdown or button, the canvas loses focus.
      // This document-level listener auto-refocuses the canvas on any arrow key
      // press so movement always works without the user having to click the canvas.
      document.addEventListener('keydown', function (e) {
        if ([37, 38, 39, 40].includes(e.keyCode)) {
          cnv.elt.focus();
        }
      }, true);
      initGame();
    }
    // ═══════════════════════════════════════════════════════════════════════════
    // P5 — DRAW (runs at 60 fps)
    // ═══════════════════════════════════════════════════════════════════════════
    function draw() {
      framesSinceStart++;
      // ── 1. Starfield ────────────────────────────────────────────────────────
      background(10, 10, 30);
      noStroke();
      fill(255, 255, 255, 100);
      for (let s of starfield) {
        s.y += s.speed;
        if (s.y > height) s.y -= height;
        ellipse(s.x, s.y, s.size, s.size);
      }
      // ── 2. Hit-flash red overlay ─────────────────────────────────────────────
      if (hitFlash > 0) {
        noStroke();
        fill(255, 0, 0, hitFlash);
        rect(0, 0, width, height);
        hitFlash = max(0, hitFlash - 10);
      }
      // ── 3. Grid lines ────────────────────────────────────────────────────────
      stroke(255, 255, 255, 50);
      strokeWeight(1);
      for (let i = 0; i <= GRID_SIZE; i++) {
        line(i * CELL_SIZE, 0, i * CELL_SIZE, height);
        line(0, i * CELL_SIZE, width, i * CELL_SIZE);
      }
      noStroke();
      // ── 4. Player smooth interpolation ──────────────────────────────────────
      let snapThreshold = 0.05;
      player.displayX = (abs(player.displayX - player.x) < snapThreshold)
        ? player.x : lerp(player.displayX, player.x, 0.25);
      player.displayY = (abs(player.displayY - player.y) < snapThreshold)
        ? player.y : lerp(player.displayY, player.y, 0.25);
      // ── 5. Alien pulse factor ────────────────────────────────────────────────
      let pulse = sin(framesSinceStart * 0.1) * 0.1 + 1;
      // ── 6. Draw grid cells ───────────────────────────────────────────────────
      for (let row = 0; row < GRID_SIZE; row++) {
        for (let col = 0; col < GRID_SIZE; col++) {
          let px = col * CELL_SIZE;
          let py = row * CELL_SIZE;
          let cell = grid[row][col];
          if (cell === 'W') {
            drawWall(px, py, row, col);
          } else if (cell === 'A') {
            drawAlien(px, py, pulse);
          }
        }
      }
      // ── 7. Draw player ───────────────────────────────────────────────────────
      drawPlayer(
        player.displayX * CELL_SIZE + CELL_SIZE / 2,
        player.displayY * CELL_SIZE + CELL_SIZE / 2
      );
      // ── 8. Score HUD ─────────────────────────────────────────────────────────
      drawScore();
      // ── 9. Game-logic tick ───────────────────────────────────────────────────
      if (!gameOver && framesSinceStart > 0 && framesSinceStart % UPDATE_INTERVAL === 0) {
        updateGame();
        // Check alien adjacency AFTER updateGame() so positions are current.
        if (!gameOver) {
          let adjacent = aliens.some(
            a => abs(a.x - player.x) + abs(a.y - player.y) === 1
          );
          if (adjacent) hitFlash = 120;
        }
      }
      // ── 10. Continuous player movement ──────────────────────────────────────
      if (!gameOver) {
        if (moveCooldown <= 0) {
          let nx = player.x, ny = player.y;
          if (keyIsDown(LEFT_ARROW)) nx--;
          else if (keyIsDown(RIGHT_ARROW)) nx++;
          else if (keyIsDown(UP_ARROW)) ny--;
          else if (keyIsDown(DOWN_ARROW)) ny++;
          if (nx !== player.x || ny !== player.y) {
            // FIX: Check BOTH grid cell AND alienPositionSet.
            // During updateGame(), alien grid cells are temporarily vacated to '.'
            // so grid[ny][nx] alone cannot be trusted. alienPositionSet always
            // reflects the true logical positions of all living aliens.
            let alienKey = nx + ',' + ny;
            if (
              nx >= 0 && nx < GRID_SIZE &&
              ny >= 0 && ny < GRID_SIZE &&
              grid[ny][nx] !== 'W'
            ) {
              if (grid[ny][nx] === 'A' || alienPositionSet.has(alienKey)) {
                triggerGameOver([...aliens], -1);
                return;
              }
              grid[player.y][player.x] = '.';
              player.x = nx;
              player.y = ny;
              grid[player.y][player.x] = 'P';
              moveCooldown = MOVE_DELAY;
            }
          }
        }
        moveCooldown = max(0, moveCooldown - 1);
      }
      // ── 11. Game-over overlay ────────────────────────────────────────────────
      if (gameOver) {
        gameOverAlpha = min(gameOverAlpha + 5, 200);
        noStroke();
        fill(0, 0, 0, gameOverAlpha);
        rect(0, 0, width, height);
        textAlign(CENTER, CENTER);
        noStroke();
        textSize(40);
        fill(255, 0, 0, gameOverAlpha);
        text('GAME OVER', width / 2, height / 2 - 60);
        textSize(26);
        fill(255, 255, 255, gameOverAlpha);
        text('Score: ' + score, width / 2, height / 2 - 10);
        textSize(22);
        fill(255, 215, 0, gameOverAlpha);
        text('Best: ' + bestScore, width / 2, height / 2 + 32);
        textSize(18);
        fill(200, 200, 200, gameOverAlpha);
        text('Press R to restart', width / 2, height / 2 + 68);
      }
    }
    // ═══════════════════════════════════════════════════════════════════════════
    // DRAWING HELPERS
    // ═══════════════════════════════════════════════════════════════════════════
    function drawWall(x, y, row, col) {
      noStroke();
      fill(80, 80, 80);
      rect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4, 5);
      fill(100, 100, 100, 50);
      for (let d of wallNoise[row][col]) {
        ellipse(x + d.dx, y + d.dy, 2);
      }
      stroke(150, 150, 150);
      strokeWeight(2);
      noFill();
      rect(x + 4, y + 4, CELL_SIZE - 8, CELL_SIZE - 8, 3);
      strokeWeight(1);
      noStroke();
    }
    function drawAlien(x, y, pulse) {
      let cx = x + CELL_SIZE / 2;
      let cy = y + CELL_SIZE / 2;
      let r = CELL_SIZE * 0.28 * pulse;
      noStroke();
      fill(255, 0, 0, 150);
      ellipse(cx, cy, CELL_SIZE * 0.5 * pulse);
      fill(200, 0, 0);
      beginShape();
      vertex(cx, cy - r);
      vertex(cx - r * 0.7, cy + r * 0.7);
      vertex(cx, cy);
      vertex(cx + r * 0.7, cy + r * 0.7);
      endShape(CLOSE);
    }
    function drawPlayer(px, py) {
      // Pulsing outer ring for visibility
      let pulse = sin(framesSinceStart * 0.12) * 0.15 + 1;
      noStroke();
      // Bright outer glow
      fill(0, 180, 255, 50);
      ellipse(px, py, CELL_SIZE * 1.1 * pulse);
      // Solid bright blue body — larger than before
      fill(30, 130, 255);
      ellipse(px, py, CELL_SIZE * 0.78);
      // Inner highlight ring
      fill(80, 200, 255, 180);
      ellipse(px, py, CELL_SIZE * 0.55);
      // White glint
      fill(255, 255, 255, 220);
      ellipse(px, py - CELL_SIZE * 0.15, CELL_SIZE * 0.22);
    }
    function drawScore() {
      scoreScale = lerp(scoreScale, 1, 0.1);
      let label = 'Score: ' + score;
      textAlign(LEFT, TOP);
      let fs = 18 * scoreScale;
      textSize(fs);
      let tw = textWidth(label) || label.length * fs * 0.6;
      noStroke();
      fill(0, 0, 0, 170);
      rect(2, 2, tw + 10, 26 * scoreScale, 3);
      fill(0, 255, 0);
      text(label, 7, 5);
      let bestLabel = 'Best: ' + bestScore;
      textAlign(RIGHT, TOP);
      textSize(14);
      let btw = textWidth(bestLabel) || bestLabel.length * 14 * 0.6;
      fill(0, 0, 0, 170);
      rect(width - btw - 14, 2, btw + 10, 22, 3);
      fill(255, 215, 0);
      text(bestLabel, width - 7, 5);
    }
    // ═══════════════════════════════════════════════════════════════════════════
    // KEYBOARD
    // ═══════════════════════════════════════════════════════════════════════════
    function keyPressed() {
      if (keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW ||
        keyCode === UP_ARROW || keyCode === DOWN_ARROW) {
        if (typeof event !== 'undefined' && event && event.preventDefault) {
          event.preventDefault();
        }
        return false;
      }
      if (gameOver && (key === 'r' || key === 'R')) {
        applySettings();
      }
    }
    // ═══════════════════════════════════════════════════════════════════════════
    // APPLY SETTINGS / RESTART
    // ═══════════════════════════════════════════════════════════════════════════
    function applySettings() {
      GRID_SIZE = parseInt(document.getElementById('gridSize').value);
      UPDATE_INTERVAL = parseInt(document.getElementById('gameSpeed').value);
      CELL_SIZE = Math.floor(Math.min(MAX_CANVAS_WIDTH / GRID_SIZE, 30));
      initGame();  // must run BEFORE resizeCanvas so draw() never sees a stale grid
      resizeCanvas(GRID_SIZE * CELL_SIZE, GRID_SIZE * CELL_SIZE);
      let cnv = document.querySelector('canvas');
      if (cnv) cnv.focus();
    }
    // ═══════════════════════════════════════════════════════════════════════════
    // INIT GAME
    // ═══════════════════════════════════════════════════════════════════════════
    function initGame() {
      grid = [];
      wallNoise = [];
      aliens = [];
      alienPositionSet = new Set(); // FIX: reset the position set on init
      score = 0;
      scoreScale = 1;
      gameOver = false;
      gameOverAlpha = 0;
      hitFlash = 0;
      moveCooldown = 0;
      framesSinceStart = -1;
      for (let row = 0; row < GRID_SIZE; row++) {
        grid[row] = [];
        wallNoise[row] = [];
        for (let col = 0; col < GRID_SIZE; col++) {
          grid[row][col] = (Math.random() < WALL_CHANCE) ? 'W' : '.';
          let dots = [];
          for (let n = 0; n < 10; n++) {
            dots.push({
              dx: Math.random() * Math.max(1, CELL_SIZE - 8) + 4,
              dy: Math.random() * Math.max(1, CELL_SIZE - 8) + 4
            });
          }
          wallNoise[row][col] = dots;
        }
      }
      // Clear a safe zone around the player spawn (SAFE_RADIUS now 2 → 5x5 clear area)
      let cx = Math.floor(GRID_SIZE / 2);
      let cy = Math.floor(GRID_SIZE / 2);
      for (let di = -SAFE_RADIUS; di <= SAFE_RADIUS; di++) {
        for (let dj = -SAFE_RADIUS; dj <= SAFE_RADIUS; dj++) {
          let ni = cy + di, nj = cx + dj;
          if (ni >= 0 && ni < GRID_SIZE && nj >= 0 && nj < GRID_SIZE) {
            grid[ni][nj] = '.';
          }
        }
      }
      player.x = cx;
      player.y = cy;
      player.displayX = cx;
      player.displayY = cy;
      grid[cy][cx] = 'P';
      spawnAlien();
      let canvasW = GRID_SIZE * CELL_SIZE;
      let canvasH = GRID_SIZE * CELL_SIZE;
      starfield = [];
      for (let i = 0; i < 50; i++) {
        starfield.push({
          x: Math.random() * canvasW,
          y: Math.random() * canvasH,
          size: Math.random() * 2 + 1,
          speed: Math.random() * 1.5 + 0.5
        });
      }
    }
    // ═══════════════════════════════════════════════════════════════════════════
    // ALIEN SPAWNING
    // ═══════════════════════════════════════════════════════════════════════════
    function spawnAlien() {
      if (aliens.length >= maxAliens()) return;
      // FIX: Build edge candidates more robustly — avoid duplicate coords
      // by using a Map keyed by "x,y". Only spawn on cells that are '.'
      // AND not already in alienPositionSet (extra safety during vacate window).
      let edgeMap = new Map();
      for (let i = 0; i < GRID_SIZE; i++) {
        let candidates = [
          { x: i, y: 0 },
          { x: i, y: GRID_SIZE - 1 },
          { x: 0, y: i },
          { x: GRID_SIZE - 1, y: i }
        ];
        for (let c of candidates) {
          let k = c.x + ',' + c.y;
          // FIX: also check alienPositionSet to avoid spawning on a temporarily-
          // vacated alien cell. grid[c.y][c.x] === '.' is insufficient during
          // the vacate window at the start of updateGame().
          if (!edgeMap.has(k)
            && grid[c.y][c.x] === '.'
            && !alienPositionSet.has(k)
            && !(c.x === player.x && c.y === player.y)) {
            edgeMap.set(k, c);
          }
        }
      }
      let pool = Array.from(edgeMap.values());
      if (pool.length === 0) return;
      let spawn = pool[Math.floor(Math.random() * pool.length)];
      aliens.push({ x: spawn.x, y: spawn.y });
      grid[spawn.y][spawn.x] = 'A';
      alienPositionSet.add(spawn.x + ',' + spawn.y); // FIX: keep set in sync
    }
    // ═══════════════════════════════════════════════════════════════════════════
    // UTILITY: Fisher-Yates shuffle (in-place)
    // ═══════════════════════════════════════════════════════════════════════════
    function shuffleArray(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        let tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;
      }
    }
    // ═══════════════════════════════════════════════════════════════════════════
    // GAME TICK
    // ═══════════════════════════════════════════════════════════════════════════
    function updateGame() {
      shuffleArray(aliens);
      // FIX: Rebuild alienPositionSet BEFORE vacating grid cells so the set
      // accurately reflects current alien positions during the move phase.
      // The set is then updated incrementally as each alien moves.
      alienPositionSet.clear();
      // (Don't re-add here — we'll add the new positions as we place them)
      // Vacate ALL alien cells from the grid before moving any alien.
      for (let a of aliens) {
        grid[a.y][a.x] = '.';
      }
      let newAliens = [];
      let claimedCells = new Set();
      for (let i = 0; i < aliens.length; i++) {
        let alien = aliens[i];
        let dx = player.x - alien.x;
        let dy = player.y - alien.y;
        // ── Primary move: dominant axis ──────────────────────────────────────
        let nx = alien.x, ny = alien.y;
        if (Math.abs(dx) >= Math.abs(dy)) {
          if (dx !== 0) nx += dx > 0 ? 1 : -1;
        } else {
          if (dy !== 0) ny += dy > 0 ? 1 : -1;
        }
        // Reached player?
        if (nx === player.x && ny === player.y) {
          triggerGameOver(newAliens, i);
          return;
        }
        let primaryKey = nx + ',' + ny;
        if (isWalkable(nx, ny) && !claimedCells.has(primaryKey)) {
          claimedCells.add(primaryKey);
          grid[ny][nx] = 'A';
          alienPositionSet.add(primaryKey); // FIX: keep set current during move phase
          newAliens.push({ x: nx, y: ny });
        } else {
          // ── Fallback: try the other axis ───────────────────────────────────
          let ax = alien.x, ay = alien.y;
          if (Math.abs(dx) >= Math.abs(dy)) {
            if (dy !== 0) ay += dy > 0 ? 1 : -1;
          } else {
            if (dx !== 0) ax += dx > 0 ? 1 : -1;
          }
          if (ax === player.x && ay === player.y) {
            triggerGameOver(newAliens, i);
            return;
          }
          let fallbackKey = ax + ',' + ay;
          if (isWalkable(ax, ay) && !claimedCells.has(fallbackKey)) {
            claimedCells.add(fallbackKey);
            grid[ay][ax] = 'A';
            alienPositionSet.add(fallbackKey); // FIX: keep set current
            newAliens.push({ x: ax, y: ay });
          } else {
            // ── Truly stuck — stay in place ──────────────────────────────────
            let stayKey = alien.x + ',' + alien.y;
            if (!claimedCells.has(stayKey)) {
              claimedCells.add(stayKey);
              grid[alien.y][alien.x] = 'A';
              alienPositionSet.add(stayKey); // FIX: keep set current
              newAliens.push({ x: alien.x, y: alien.y });
            } else {
              // FIX: if stayKey is already claimed, find the nearest unclaimed
              // walkable neighbor rather than silently dropping the alien.
              let rescued = false;
              let neighbors = [
                { x: alien.x - 1, y: alien.y },
                { x: alien.x + 1, y: alien.y },
                { x: alien.x, y: alien.y - 1 },
                { x: alien.x, y: alien.y + 1 }
              ];
              for (let nb of neighbors) {
                let nbKey = nb.x + ',' + nb.y;
                if (isWalkable(nb.x, nb.y) && !claimedCells.has(nbKey)) {
                  claimedCells.add(nbKey);
                  grid[nb.y][nb.x] = 'A';
                  alienPositionSet.add(nbKey); // FIX: keep set current
                  newAliens.push({ x: nb.x, y: nb.y });
                  rescued = true;
                  break;
                }
              }
              // Alien truly has no place — remove gracefully (board fully congested)
            }
          }
        }
      }
      // ── Deduplicate by coordinate — final safety net ─────────────────────
      {
        let seen = new Set();
        let deduped = [];
        for (let a of newAliens) {
          let k = a.x + ',' + a.y;
          if (!seen.has(k)) {
            seen.add(k);
            deduped.push(a);
          } else {
            // FIX: clear ghost 'A' cell written by duplicate alien.
            // Only clear if the cell is 'A' — don't clear if another entity
            // has since claimed it (shouldn't happen but defensive check).
            if (grid[a.y][a.x] === 'A') grid[a.y][a.x] = '.';
            // Also remove from alienPositionSet since this duplicate is dropped.
            // (The first occurrence already added its key, so this is safe.)
          }
        }
        aliens = deduped;
        // FIX: Rebuild alienPositionSet from the final deduped list to ensure
        // perfect consistency. This is the single source of truth.
        alienPositionSet.clear();
        for (let a of aliens) {
          alienPositionSet.add(a.x + ',' + a.y);
        }
      }
      // Maybe spawn a new alien (capped by maxAliens inside spawnAlien)
      if (Math.random() < ALIEN_SPAWN_RATE) spawnAlien();
      // Score: +1 surviving tick, +5 per alien currently on the board.
      let tickPoints = 1 + aliens.length * 5;
      score += tickPoints;
      scoreScale = 1.3;
      if (score > bestScore) {
        bestScore = score;
        document.getElementById('bestScoreDisplay').textContent = bestScore;
      }
    }
    // FIX: isWalkable is used ONLY for alien pathfinding during updateGame.
    // During updateGame, alien cells have been vacated to '.' in the grid,
    // but claimedCells prevents two aliens landing on the same spot.
    // For player movement blocking, alienPositionSet is used instead (see draw).
    function isWalkable(nx, ny) {
      return (
        nx >= 0 && nx < GRID_SIZE &&
        ny >= 0 && ny < GRID_SIZE &&
        grid[ny][nx] === '.'
        // Note: 'P' and 'A' are NOT walkable, '.' is.
        // 'P' (player) is non-walkable so aliens trigger game over via
        // explicit position checks, not isWalkable.
      );
    }
    // ═══════════════════════════════════════════════════════════════════════════
    // GAME OVER
    // ═══════════════════════════════════════════════════════════════════════════
    // FIX: triggerGameOver now accepts (processedAliens, catchIndex) where
    // catchIndex == -1 means the player walked into an alien (not the other way).
    // In both cases, restore grid and alien state for the death frame.
    function triggerGameOver(processedAliens, catchIndex) {
      gameOver = true;
      if (score > bestScore) {
        bestScore = score;
        document.getElementById('bestScoreDisplay').textContent = bestScore;
      }
      // All alien cells were vacated at the start of updateGame().
      // Restore grid for already-processed aliens at their new positions.
      for (let a of processedAliens) {
        grid[a.y][a.x] = 'A';
      }
      // Mark the collision point (player's cell) as hit
      grid[player.y][player.x] = 'A';
      // Restore unprocessed aliens at their original positions
      if (catchIndex >= 0) {
        for (let j = catchIndex + 1; j < aliens.length; j++) {
          grid[aliens[j].y][aliens[j].x] = 'A';
          processedAliens.push(aliens[j]);
        }
      }
      aliens = processedAliens;
      // FIX: Sync alienPositionSet with final alien state for consistency,
      // even though game is over (prevents any residual movement attempts).
      alienPositionSet.clear();
      for (let a of aliens) {
        alienPositionSet.add(a.x + ',' + a.y);
      }
    }
  </script>
</body>

</html>